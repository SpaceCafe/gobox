package httpserver

import (
	"net/http"
	"strings"
	"unicode"

	"github.com/gin-gonic/gin"
)

// Problem is used for a standardised error handling for the REST API that the IETF
// has worked out in [RFC 7807](https://datatracker.ietf.org/doc/html/rfc7807).
type Problem struct {

	// Type is a URI reference that identifies the problem type.
	Type string `json:"type"`

	// Title is a short, human-readable summary of the problem.
	Title string `json:"title"`

	// Status equals the HTTP status code generated by the origin server for this occurrence of the problem.
	// A list with status codes and their purpose:
	//   - 400 Bad Request: the input parameters are incorrect or missing, or the request itself is incomplete.
	//   - 401 Unauthorized: the request is unauthenticated.
	//   - 403 Forbidden: the client is not authorized to perform this request.
	//   - 404 Not Found: the resource does not exist.
	//   - 405 Method Not Allowed: the HTTP method is not allowed for the requested resource.
	//   - 406 Not Acceptable: the Accept header does not match. Also, can be used to refuse request.
	//   - 409 Conflict: an attempt is made for a duplicate create operation.
	//   - 429 Too Many Requests: a user sends too many requests in a given amount of time
	//   - 500 Internal Server Error: a generic server error
	//   - 502 Bad Gateway: the upstream server or third-party service calls fail
	//   - 503 Service Unavailable: something unexpected happened at the server
	Status int `json:"status"`

	// Detail contains a human-readable explanation specific to this occurrence of the problem.
	Detail string `json:"detail"`

	// Instance is a URI reference that identifies the specific occurrence of the problem.
	// Example: /item/list
	Instance string `json:"instance"`
}

// NewProblem creates a new instance of Problem with default values, if not specified by function parameters.
func NewProblem(problemType string, title string, status int, detail string) *Problem {
	p := &Problem{
		Type:   "/errors/unspecified-error",
		Title:  "Unspecified error",
		Status: http.StatusInternalServerError,
		Detail: "This type of error was not specified",
	}

	if len(problemType) > 0 {
		p.Type = "/errors/" + problemType
	}

	if len(problemType) == 0 && len(title) > 0 {
		// Convert title to kebab case and set it as type.
		words := strings.FieldsFunc(title, func(r rune) bool {
			return !unicode.IsLetter(r) && !unicode.IsNumber(r)
		})
		p.Type = "/errors/" + strings.ToLower(strings.Join(words, "-"))
	}

	if len(title) > 0 {
		p.Title = title
	}

	if status >= 400 && status < 600 {
		p.Status = status
	}

	if len(detail) > 0 {
		p.Detail = detail
	}

	return p
}

// setError appends the human-readable error message to the detail field of the problem.
func (r *Problem) setError(err error) {
	if err != nil {
		r.Detail = r.Detail + "\n\nReason: " + err.Error()
	}
}

// setInstance sets the request path to the instance field of the problem.
func (r *Problem) setInstance(ctx *gin.Context) {
	if len(r.Instance) == 0 {
		r.Instance = ctx.Request.URL.Path
	}
}

func (r *Problem) sendResponse(ctx *gin.Context) {
	ctx.Writer.Header().Set("Content-Type", "application/problem+json")
	ctx.AbortWithStatusJSON(r.Status, r)
}

// Abort sets the correct content type and a JSON formatted problem response.
// If not set, the instance field is filled automatically.
func (r *Problem) Abort(ctx *gin.Context) {
	problem := *r
	problem.setInstance(ctx)
	problem.sendResponse(ctx)
}

// AbortWithError is a wrapper that calls setError and Abort.
func (r *Problem) AbortWithError(err error, ctx *gin.Context) {
	problem := *r
	problem.setError(err)
	problem.Abort(ctx)
}
